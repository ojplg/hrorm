<!DOCTYPE html>
<html lang="en">
<head>
    <title>hrorm - Documentation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.0/mini-default.min.css">
    <link rel="stylesheet" href="/css/hrorm.css">
    <meta charset="utf-8"/>
</head>
<body>


<div class="container">
    <div class="row">

        <div class="col-sm-3">
            <nav id="documentation_navigation">

                <a href="/">hrorm</a>

                <hr class="thin">

                <a href="#introduction">Introduction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>

                <a href="#concepts">Concepts</a>
                <a href="#designing_entities" class="sublink-1">Designing Entities</a>
                <a href="#java_objects" class="sublink-2">Java Objects</a>
                <a href="#sql_schema" class="sublink-2">SQL Schema</a>
                <a href="#relationships" class="sublink-1">Relationships</a>
                <a href="#parent_child_relations_concept" class="sublink-2">Parent-Child Relations</a>
                <a href="#sibling_relations_concept" class="sublink-2">Sibling Relations</a>
                <a href="#association_relations_concept" class="sublink-2">Association Relations</a>
                <a href="#transactions" class="sublink-1">Transactions</a>

                <a href="#daobuilders">DaoBuilders</a>
                <a href="#one_table" class="sublink-1">One Table</a>
                <a href="#generic_columns" class="sublink-1">Generic Columns</a>
                <a href="#parent_child_relations" class="sublink-1">Parent-Child Relations</a>
                <a href="#sibling_relations" class="sublink-1">Sibling Relations</a>
                <a href="#association_relations" class="sublink-1">Association Relations</a>
                <a href="#n_plus_one_queries" class="sublink-1">N+1 Queries</a>
                <a href="#immutable_models" class="sublink-1">Immutable Models</a>
                <a href="#keyless_entities" class="sublink-1">Keyless Entities</a>
                <a href="#constraints" class="sublink-1">Constraints</a>
                <a href="#validation" class="sublink-1">Validation</a>

                <a href="#daos">Daos</a>
                <a href="#insert" class="sublink-1">Insert</a>
                <a href="#select" class="sublink-1">Select</a>
                <a href="#update" class="sublink-1">Update</a>
                <a href="#delete" class="sublink-1">Delete</a>
                <a href="#association_daos" class="sublink-1">Associations</a>
                <a href="#functions" class="sublink-1">Functions</a>
                <a href="#atomic" class="sublink-1">Atomic</a>
                <a href="#folding" class="sublink-1">Folding</a>
                <a href="#sql" class="sublink-1">SQL</a>


                <a href="#miscellaneous">Miscellaneous</a>
                <a href="#dates_and_times" class="sublink-1">Dates and Times</a>
                <a href="#schema" class="sublink-1">Schema</a>
                <a href="#exceptions" class="sublink-1">Exceptions</a>
                <a href="#logging" class="sublink-1">Logging</a>
                <a href="#visibility" class="sublink-1">Visibility</a>

            </nav>
        </div>

        <div class="col-sm-9">

            <a id="introduction"></a>
            <h2>Introduction</h2>
            <hr>

            <p>Interactions with hrorm have two major points: building <code>Dao</code> objects and then using them.</p>

            <p><code>Dao</code> building is accomplished with the aptly named <code>DaoBuilder</code> class.
                <code>DaoBuilder</code> objects are part of the one-time (static, singleton) initiation of
                your application. There is little point in having more than one builder of any entity type.
                Of course, some care must be taken: by their nature, <code>DaoBuilder</code> objects are
                mutable, so if you directly expose them to the rest of your application during start up,
                it's possible that you can do something stupid.
            </p>

            <p><code>Dao</code> objects themselves are what perform the actual tasks of persisting and
                instantiating entity objects. To make a <code>Dao</code> requires a <code>Connection</code>
                object. Since a <code>Dao</code> keeps a stateful <code>Connection</code> to the underlying
                data store, it is dangerous to share instances across threads. Generally, the idea is to
                instantiate a <code>Dao</code> when you need it, and then allow it to be garbage collected.
                It is up the application itself to deal with reaping the <code>Connection</code>, with some exceptions
                noted below.</p>

            <p>Also take a look at the <a href="/#quick_start">Quick Start</a> and <a
                    href="/javadocs/latest">Javadocs</a>.</p>

            <a id="concepts"></a>
            <h2>Concepts</h2>
            <hr>

            <p>Before diving into the nuts-and-bolts of how to use hrorm, it is helpful to understand the
            ideas it implements.</p>

            <div class="card fluid">

                <a id="designing_entities"></a>
                <h2>Designing Entities</h2>

                <hr>

                <p>Using hrorm means accepting some restrictions on how your entities (both the Java classes
                and the SQL schema) are designed. Some of these restrictions are good practices regardless of
                how database and object models are built.</p>

                <a id="java_objects"></a>
                <h4>Java Objects</h4>

                <ul>
                    <li>Every entity class should have a <code>Long</code> identifier field that will be used as a
                        primary key.
                        Hrorm will populate this field from a sequence (see restrictions on
                        schema below), unless you use an <a href="#immutable_models">immutable model</a>.
                        The primary key will be used it when hrorm performs updates. (There is limited support for
                        <a href="#keyless_entities">keyless entities</a>.)
                    </li>
                    <li>Hrorm expects to work with Javabean like entities with public getters and setters or
                        with entities with public getters for fields and related builder objects with setters
                        for the individual fields. (See documentation for <a
                                href="#immutable_models">Immutable Models</a>.)
                    </li>
                    <li>Hrorm expects child relationships to be modeled as <code>List</code> types exclusively. No sets
                        or arrays or other collections.
                    </li>
                </ul>

                <a id="sql_schema"></a>
                <h4>SQL Schema</h4>

                <ul>
                    <li>Hrorm expects every table to have a numeric primary key, except in the case of <a href="#keyless_entities">keyless entities</a>.
                    </li>
                    <li>Hrorm will populate the primary keys on inserts with values it pulls from a sequence. You can
                        create a separate sequence for each table, or just have one overall sequence if you want. Hrorm
                        does not care, but it wants a sequence for inserts.
                    </li>
                </ul>

                <p>
                    Hrorm encourages the use of five basic types for building entities:
                    <code>Long</code>, <code>BigDecimal</code>, <code>String</code>, <code>Boolean</code>,
                    and <code>Instant</code>. However, by using a <a href="#generic_columns"><code>GenericColumn</code></a>
                    you can easily support any type with JDBC support that you want. Additionally, hrorm
                    supports a simple mechanism
                    for persisting values that can be converted to and from any JDBC supported type, intended
                    for enumerated or other non-primitive types.
                </p>

            </div>

            <div class="card fluid">

                <a id="relationships"></a>
                <h3>Relationships</h3>

                <hr>

                <p>One point of using a relational database as opposed to a document store or other mechanism
                    is to preserve the structure of relations between entities.
                    Hrorm supports two kinds of relationships: a parent-child relation where one object contains a list
                    of children, and a sibling relationship, where one object expresses a connection with another
                    entity.</p>

                <a id="parent_child_relations_concept"></a>
                <h4>Parent-Child Relations</h4>

                <p>These relations are defined by using the <code>DaoBuilder.withParent()</code> and
                    <code>DaoBuilder.withChildren()</code> methods.</p>

                <p>In a parent-child relationship, the child is assumed to be completely dependent on the parent, so
                    that its very existence depends on the existence of the parent.</p>

                <p>Take a look at the <a href="/#quick_start">recipe example</a>.
                    If a recipe is deleted, it makes no sense to preserve the
                    ingredient rows. So, if a call is made on the recipe <code>Dao.delete()</code> method, all
                    the ingredients will be deleted too. Likewise, on an update hrorm will make the necessary inserts,
                    updates, and deletes to the ingredients table to synchronize the object state.</p>

                <p>In fact, you would rarely want to instantiate an ingredients <code>Dao</code> directly.
                    Hrorm will do the work for you.</p>

                <p>One tricky thing about these relationships is the reversal in how ownership is expressed between
                    the database schema and the object model. In the object model, the Hand object has Finger objects.
                    In the database, the FINGER table has foreign key references to the HAND table. With hrorm, the
                    <code>DaoBuilder</code> object of both the parent and child need to understand
                    the relationship, not just one or the other.</p>

                <a id="sibling_relations_concept"></a>
                <h4>Sibling Relations</h4>

                <p>These relations are defined by using the <code>DaoBuilder.withJoinColumn()</code> method.</p>

                <p>These are relations between two objects where one object refers in a dependent, but not
                    controlling, way.</p>

                <p>In the  <a href="/#quick_start">recipe example</a>, the relationship between an Author and a Recipe is of this type.
                    A Recipe requires an Author, but neither owns the other.
                </p>

                <p>Hrorm requires that sibling objects be persisted first, and will not handle transitive persistence
                    automatically. Likewise, deleting a Recipe will not cause a cascading delete of an Author
                    record.</p>

                <p>Note well: Hrorm will do nothing to prevent a dependent sibling from being deleted. The application
                    code, or database schema constraints, (or both!) must be in place to prevent orphaned records of
                    that type.</p>

                <a id="association_relations_concept"></a>
                <h4>Association Relations</h4>

                <p>Hrorm supports many-to-many relations through <code>AssociationDao</code> objects.
                    An <code>AssociationDao</code> is an object that allows the caller
                to create or delete links between entities. Then the associates of any individual
                entity can be selected, in either direction.</p>

                <p>As an example, think of movies and actors. Actors appear in multiple movies, and
                movies include multiple actors. Using Hrorm we would create independent classes modeling
                both actors and movies, and then create an <code>AssociationDao</code> allowing
                us to load either all the actors in any movie, or all the movies that an actor
                appeared in.</p>

                <p><code>AssociationDao</code> objects do not implement the full <code>Dao</code>
                interface. In fact, the interface is completely different. They have one purpose
                only: for managing the links between entities. They must be backed by a table of
                three columns: a primary key, and foreign keys to the two entities being linked.</p>

            </div>


            <div class="card fluid">

                <a id="transactions"></a>
                <h3>Transactions</h3>

                <hr>

                <p>For the most part, hrorm tries to stay out of the transaction handling business.
                    Applications know what changes must be transactions, hrorm does not. However, hrorm's
                    commands to insert, update, and delete records can lead to multiple SQL statements
                    being run, due to the handling of parent-child relationships. This means in the case
                    of an error, the database is at risk of coming to an illegal state.</p>

                <p>If nested transactions were supported natively by every database provider,
                    it would probably be correct to wrap database mutations in an internally nested transaction
                    and commit or rollback on completion. This is not possible for every provider,
                    and mechanisms for how to accomplish this are not identical even for databases that
                    do provide for transaction nesting.</p>

                <p>Hrorm does give a minimal amount of support to attempt to alleviate these issues. Hrorm provides
                    a <a href="/javadocs/latest/org/hrorm/Transactor.html"><code>Transactor</code></a> class
                    with a couple of methods to eliminate the boilerplate <code>try ... catch ... finally</code>
                    blocks necessary for doing transactions. In keeping with the hrorm ethos, these methods
                    do not declare any checked exceptions. Keep in mind that a <code>Transactor</code> will
                    <b>automatically close its connection</b> whether or not it completes with a commit or a rollback.
                </p>

                <p>In addition, the <code>Dao</code> interface provides cognate methods for <code>insert</code>,
                    <code>update</code>, and <code>delete</code> named <code>atomicInsert</code>,
                    <code>atomicUpdate</code>, and <code>atomicDelete</code>. These methods provide
                    a no-fuss way to do mutations of parent-child relations. However, these methods
                    must be used with care! In addition to a possibly unexpected early commit if these methods
                    are accidentally used in a larger transaction, remember that, as above, these methods
                    will also <b>close the connection</b> they use when complete.</p>

                <p>There is no one-size-fits-all solution to how to marry the problem of database
                    to object mapping with the problems of transactions and atomicity. For this reason,
                    hrorm mostly just tries to stay out of the way.</p>

            </div>


            <a id="daobuilders"></a>
            <h2>Dao Builders</h2>
            <hr>

            <p>Hrorm provides three builder classes: one for Javabean style entities (<code>DaoBuilder</code>),
                one for immutable object models with separate builder objects (<code>IndirectDaoBuilder</code>),
                and one for keyless entities (<code>IndirectKeylessDaoBuilder</code>, that works for both
                mutable or immutable classes).
                All three support very similar methods, and though most of the examples below show a plain
                <code>DaoBuilder</code>, using an immutable or keyless model is very similar.</p>

            <a id="one_table"></a>
            <div class="card fluid">
                <h3>One Table</h3>
                <hr>
                <p>The easiest case for any ORM tool is persisting a single object backed by a single table.
                    Let's work on persisting a model for a person that includes the following elements:</p>
                <ul>
                    <li>Name (a string or text)</li>
                    <li>Weight in kilograms (an integer)</li>
                    <li>Height in meters (a decimal)</li>
                    <li>Birthday (a date)</li>
                    <li>High school graduate? (a boolean)</li>
                    <li>Hair color (an enumerated type)</li>
                </ul>

                <p>To model the person entity, we write a Java Person object.</p>

                <pre>
    class Person {
        Long id;
        String name;
        long weight;
        BigDecimal height;
        Instant birthday;
        Boolean isHighSchoolGraduate;
        HairColor hairColor;
    }</pre>

                <p>A few small points.</p>

                <ul>
                    <li>Use your imagination to fill in getters, setters, equals, hashCode, etc.</li>
                    <li>We have one extra field that we did not have in our logical model: an id field that is to be
                        used
                        for persistence.
                    </li>
                    <li>Assume that there is an enumerated type for hair color: <code>HairColor.Black</code>, <code>HairColor.Brown</code>,
                        etc.
                    </li>
                </ul>

                <p>In the database we will create two structures for persisting this class: a table to store the data
                    and a sequence to issue the IDs.</p>

                <pre>
    CREATE SEQUENCE PERSON_SEQUENCE;

    CREATE TABLE PERSON_TABLE (
        ID INTEGER PRIMARY KEY,
        NAME TEXT,
        WEIGHT INTEGER,
        HEIGHT DECIMAL,
        BIRTHDAY TIMESTAMP,
        IS_HIGH_SCHOOL_GRADUATE BOOLEAN,
        HAIR_COLOR TEXT
    );</pre>

                <p>Note the somewhat different types than in the Java code.</p>

                <p>To translate between the database representation and the Java representation, we plan to use
                    a <code>Dao</code> object. We could build that directly, but hrorm provides a DaoBuilder
                    class that makes things much easier. In hrorm, both <code>Dao</code> objects and their builders
                    are parameterized on the type of thing they persist. We start off by simply calling the
                    <code>DaoBuilder</code> constructor.</p>

                <pre>
    DaoBuilder&lt;Person&gt; daoBuilder = new DaoBuilder&lt;&gt;("PERSON_TABLE", Person::new);</pre>

                <p>The constructor takes two arguments: the name of the table and a no-argument method for
                    creating a new instance of the parameterized type.</p>

                <p>Next, we need to define the primary key for this entity.</p>

                <pre>
    daoBuilder.withPrimaryKey("ID","PERSON_SEQUENCE", Person::getId, Person::setId);</pre>

                <p>The primary key is defined with four elements:</p>

                <ol>
                    <li>The name of the primary key column in the table ("ID")</li>
                    <li>The name of the sequence that populates the primary keys ("PERSON_SEQUENCE")</li>
                    <li>A function that retrieves the primary key (of type <code>Long</code>) from the
                        <code>Person</code> object.
                    </li>
                    <li>A function that can set the primary key onto the object.</li>
                </ol>

                <p>With that covered, we can being to teach the <code>DaoBuilder</code> about the individual data
                    elements. First, we will teach it about the name field.</p>

                <pre>
    daoBuilder.withStringColumn("NAME", Person::getName, Person::setName);</pre>

                <p>This explains that that table has a column named "NAME" and that the value in the table can
                    be populated from calling <code>getName()</code> on a <code>Person</code>, and that value
                    can be set by calling <code>setName()</code>. There are other methods on the <code>DaoBuilder</code>
                    for other Java types.</p>

                <p>For the integer weight value (which should actually be a <code>Long</code> or <code>long</code>,
                    not an <code>int</code> or <code>short</code>).</p>

                <pre>
    daoBuilder.withLongColumn("WEIGHT", Person::getWeight, Person::setWeight);</pre>

                <p>For fractional, decimal, or floating point values, hrorm supports the
                    <code>java.math.BigDecimal</code> type.</p>

                <pre>
    daoBuilder.withBigDecimalColumn("HEIGHT", Person::getHeight, Person::setHeight);</pre>

                <p>For dates and times, hrorm supports the <code>java.time.Instant</code> type.</p>

                <pre>
    daoBuilder.withInstantColumn("BIRTHDAY", Person::getBirthday, Person::setBirthday);</pre>

                <p>And similarly for boolean values. Not all databases support a Boolean type. For
                    those, you should use the Converter apparatus, as with an enumerated type.
                </p>

                <pre>
    daoBuilder.withBooleanColumn("IS_HIGH_SCHOOL_GRADUATE", Person::isHighSchoolGraduate, Person::setHighSchoolGraduate);</pre>

                <p>For the enumerated <code>HairColor</code> type, hrorm needs a bit more help, via an implementation
                    of its <code>Converter</code> interface. We need a simple class that looks like this:</p>

                <pre>
    class HairColorConverter implements Converter&lt;HairColor, String&gt; {
        @Override
        public String from(HairColor item) {
            return item.getColorName();
        }

        @Override
        public HairColor to(String s) {
            return HairColor.forColorName(s);
        }
    }</pre>

                <p>Once the <code>Converter</code> exists, we can teach the <code>DaoBuilder</code> about it
                    and the hair color field.</p>

                <pre>
    daoBuilder.withConvertingStringColumn("HAIR_COLOR", Person::getHairColor, Person::setHairColor, new HairColorConverter());</pre>

                <p>Notice that in addition to the usual fields for column name, getter, and setter, we additionally
                    must specify the conversion mechanism.</p>

                <p>That completes the <code>DaoBuilder</code>. Now we can actually build a
                    <code>Dao&lt;Person&gt;</code>
                    object, assuming we have a <code>java.sql.Connection</code>.</p>

                <p>But before that, we should note that the <code>DaoBuilder</code> supports a fluent interface,
                    so we could write all of the above as:</p>

                <pre>
    DaoBuilder&lt;Person&gt; daoBuilder = new DaoBuilder&lt;&gt;("PERSON_TABLE", Person::new)
                .withPrimaryKey("ID","PERSON_SEQUENCE", Person::getId, Person::setId)
                .withStringColumn("NAME", Person::getName, Person::setName)
                .withLongColumn("WEIGHT", Person::getWeight, Person::setWeight)
                .withBigDecimalColumn("HEIGHT", Person::getHeight, Person::setHeight)
                .withInstantColumn("BIRTHDAY", Person::getBirthday, Person::setBirthday)
                .withBooleanColumn("IS_HIGH_SCHOOL_GRADUATE", Person::isHighSchoolGraduate, Person::setHighSchoolGraduate)
                .withConvertingStringColumn("HAIR_COLOR", Person::getHairColor, Person::setHairColor, new HairColorConverter());</pre>

                <p>In just 8 lines of code, we have taught hrorm everything it needs to know to CRUD <code>Person</code>
                    objects.</p>
            </div>

            <a id="generic_columns"></a>
            <div class="card fluid">
                <h3>Generic Columns</h3>
                <hr>

                <p>
                    In addition to the built-in column types shown above, hrorm allows you to
                    create arbitrary column types. (See the javadocs for
                    <a href="/javadocs/latest/org/hrorm/GenericColumn.html"><code>GenericColumn</code></a>).
                </p>

                <p>
                    To define a generic column, hrorm needs to know three things.
                </p>

                <ul>
                    <li>How to populate a <code>java.sql.PreparedStatemnt</code> with the Java type
                        this column supports.
                    </li>
                    <li>How to read the type from a <code>java.sql.ResultSet</code>.</li>
                    <li>What SQL type this is, as defined in the <code>java.sql.Types</code> class.
                    (This is important for validation and for setting null values correctly.)</li>
                </ul>

                <p>To define a column that supports the <code>int</code> primitive or <code>Integer</code> type
                    (as opposed to <code>long</code>) you would write code like this:</p>

<pre>
    GenericColumn&lt;Integer&gt; integerColumn = new GenericColumn<>(
        PreparedStatement::setInt,
        ResultSet::getInt,
        java.sql.Types.Integer);</pre>

                <p>
                    The example above is particularly simple, since the JDBC already knows how to
                    handle <code>int</code> values, but the interfaces allow you to write code
                    of arbitrary complexity and inject it into hrorm. Moreover, hrorm already
                    provides a column of that type as a static instance variable,
                    <code>GenericColumn.INTEGER</code>, as well as a number of other types.
                </p>

                <p>
                    Once you have defined a <code>GenericColumn</code>, you add it to your DAO builder
                    using the <code>withGenericColumn()</code> method, very similarly to the built-in provides
                    column types.
                </p>

                <p>Additionally, you can combine a <code>GenericColumn</code> with a
                    <a href="/javadocs/latest/org/hrorm/Converter.html"><code>Converter</code></a>.
                    This allows you to persist as one type (one that makes sense to the database) but
                    populate your models with another. This allows maximum flexibility, and the possibility
                    of using the same <code>GenericColumn</code> in the database to represent a number
                    of different types in your object model.</p>
            </div>

            <a id="parent_child_relations"></a>
            <div class="card fluid">
                <h3>Parent-Child Relations</h3>
                <hr>

                <p>When one entity contains a collection of other entities, hrorm calls that a parent child
                    relation.</p>

                <p>Here is a simple model for tracking inventories of stocks of things through time. At each instant
                    that we measure, we want to know what quantity of each product we have.</p>

                <pre>
    public class Inventory {
        Long id;
        Instant date;
        List&lt;Stock&gt; stocks;
    }

    public class Stock {
        Long id;
        String productName;
        BigDecimal amount;
    }</pre>

                <p>The <code>Inventory</code> class represents a snapshot in time of what was available in inventory,
                    modeled as a <code>List</code> of <code>Stock</code> items, each of which contains a product name
                    and a decimal quantity of how much of that thing is available. Notice that the <code>Stock</code>
                    model
                    includes a reference to the inventory ID, but not the inventory object itself.</p>

                <p>To model this in the database, we make each item in the <code>STOCK</code> table point back to
                    an <code>INVENTORY</code> record, as follows.</p>

                <pre>
    CREATE TABLE INVENTORY (
        ID INTEGER PRIMARY KEY,
        DATE TIMESTAMP
    );

    CREATE TABLE STOCK (
        ID INTEGER PRIMARY KEY,
        INVENTORY_ID INTEGER,
        PRODUCT_NAME TEXT,
        AMOUNT DECIMAL
    );

    CREATE SEQUENCE INVENTORY_SEQUENCE;
    CREATE SEQUENCE STOCK_SEQUENCE;</pre>

                <p>To model this in hrorm, we need to teach it about the parent-child relationship between the two
                    entities
                    using the <code>DaoBuilder.withParentColumn()</code> and <code>DaoBuilder.withChildren()</code>
                    methods.
                    First we make a Dao for the <code>Stock</code> entity.</p>

                <pre>
    DaoBuilder&lt;Stock&gt; stockDaoBuilder = new DaoBuilder&lt;&gt;("STOCK", Stock::new)
            .withPrimaryKey("ID","STOCK_SEQUENCE", Stock::getId, Stock::setId)
            .withParentColumn("INVENTORY_ID")
            .withStringColumn("PRODUCT_NAME", Stock::getProductName, Stock::setProductName)
            .withBigDecimalColumn("AMOUNT", Stock::getAmount, Stock::setAmount);</pre>

                <p>The column <code>INVENTORY_ID</code> is marked not as an integer column,
                    but with the special <code>withParentColumn</code> method.
                    An entity can have only one parent. In the <code>Inventory</code>
                    <code>DaoBuilder</code> we use the <code>withChildren</code> method
                    to complete the relationship definition.</p>

                <pre>
    DaoBuilder&lt;Inventory&gt; inventoryDaoBuilder = new DaoBuilder&lt;&gt;("INVENTORY", Inventory::new)
            .withPrimaryKey("ID", "INVENTORY_SEQUENCE", Inventory::getId, Inventory::setId)
            .withInstantColumn("DATE", Inventory::getDate, Inventory::setDate)
            .withChildren(Inventory::getStocks, Inventory::setStocks, stockDaoBuilder);</pre>

                <p>When we create a <code>Dao</code> in this fashion we create a category of entity, the child,
                    that is wholly dependent upon another, the parent. Whenever we insert, update, delete, or
                    select the parent entity, the changes we make flow through the children and transitively
                    to their children.</p>

                <p>Be careful, if you do not want the children to be deleted, this is not the relationship
                    you want to build. In particular, remember that issuing an <code>update</code>
                    will result not just in a SQL <code>UPDATE</code> in the database, but possibly
                    a whole series of <CODE>INSERT</CODE>, <code>UPDATE</code>, and <code>DELETE</code>
                    queries being run.</p>

                <p>Hrorm always understands child objects to be members of type <code>List</code>.
                    No other collection type is supported.</p>

                <h5>Back-References</h5>

                <p>If your object model for includes a back-reference from the child to the parent,
                    Hrorm will populate it for you. If in the model above, the <code>Stock</code>
                    class had a reference to its parent <code>Inventory</code> we could use an
                    overloaded <code>withParentColumn()</code> method call on its <code>DaoBuilder</code>
                    as follows:</p>

                <pre>
    .withParentColumn("INVENTORY_ID", Stock::getInventory, Stock::setInventory)</pre>

                <p>That will cause the reference to the parent object to be automatically
                    set when using any of the <code>Dao</code> <code>select</code> methods.</p>

            </div>

            <a id="sibling_relations"></a>
            <div class="card fluid">
                <h3>Sibling Relations</h3>
                <hr>

                <p>When one entity object contains a reference to another entity object, hrorm calls that a
                    sibling or join relationship.</p>

                <p>Consider a model of cities and states, where each city contains a reference to a state.</p>

                <pre>
    class State {
        Long id;
        String name;
    }

    class City {
        Long id;
        String name;
        State state;
    }</pre>

                <p>This could be backed by this schema.</p>

                <pre>
    CREATE TABLE STATE (
        ID INTEGER PRIMARY KEY,
        NAME TEXT,
    );

    CREATE TABLE CITY (
        ID INTEGER PRIMARY KEY,
        NAME TEXT,
        STATE_ID INTEGER
    );

    CREATE SEQUENCE STATE_SEQUENCE;
    CREATE SEQUENCE CITY_SEQUENCE;</pre>

                <p>Creating the <code>State</code> <code>DaoBuilder</code> is trivial.</p>

                <pre>
    DaoBuilder&lt;State&gt; stateDaoBuilder = new DaoBuilder&lt;&gt;("STATE", State::new)
            .withPrimaryKey("ID", "STATE_SEQUENCE", State::getId, State::setId)
            .withStringColumn("NAME", State::getName, State::setName);</pre>

                <p>There is one new trick to creating the <code>City</code> <code>DaoBuilder</code>: using the
                    <code>DaoBuilder.joinColumn()</code> method which will refer to the <code>stateDaoBuilder</code>
                    we just defined.</p>

                <pre>
     DaoBuilder&lt;City&gt; cityDaoBuilder = new DaoBuilder&lt;&gt;("CITY", City::new)
            .withPrimaryKey("ID", "CITY_SEQUENCE", City::getId, City::setId)
            .withStringColumn("NAME", City::getName, City::setName)
            .withJoinColumn("STATE_ID", City::getState, City::setState, stateDaoBuilder);</pre>

                <p>The <code>withJoinColumn</code> method accepts an extra parameter: a <code>DaoDescriptor</code>.
                    Both <code>DaoBuilder</code> and the <code>Dao</code> class implement this interface. Generally,
                    it's much more convenient to create all the builder objects together.</p>

                <p><b>Sibling or join relationships in hrorm are one-way.</b> One object declares that it has a
                    reference
                    to another. Trying to make a circular relationship will lead to errors.</p>

                <p>When hrorm instantiates objects like <code>City</code> from the database, it automatically
                    instantiates the appropriate sibling <code>State</code> objects and sets the field in the
                    <code>City</code> object.</p>

                <p>Of course, you could just treat these as two one-table <code>Dao</code> objects, and then
                    right some code to glue things together. In addition to being inconvenient, this will likely
                    have poorer performance, since hrorm will issue a SQL left join to load the <code>City</code>
                    and <code>State</code> objects with one query.</p>

                <p>Objects can have several join columns, and those objects can have their own join columns.
                    Hrorm will attempt to transitively load the entire object graph when a <code>select()</code> method
                    is called
                    on the <code>Dao</code>. There is a limit to how many joins hrorm can perform. Additionally, there
                    is a limit to how many joins a database engine will allow. Consider this when designing
                    <code>Dao</code>
                    objects.
                    Also remember, sibling relationships are for reading and populating objects,
                    not for making saves or updates. If a sibling object is mutated, it must be saved itself.</p>

            </div>

            <a id="association_relations"></a>
            <div class="card fluid">
                <h3>Association Relations</h3>
                <hr>

                <p>
                    Hrorm supports many-to-many relations through <code>AssociationDao</code>
                    and <code>AssociationDaoBuilder</code> objects. The object model should be
                    of two independent entities: neither should contain a reference to the other.
                </p>

                <p>
                    As an example, consider the following model of actors and movies.
                </p>

                <pre>
    public class Actor {
        Long id;
        String name;
    }

    public class Movie {
        Long id;
        String title;
    }</pre>

                <p>It does not make sense to make either the parent object or to have a single
                reference between the two classes in either direction. But we do want to create links
                between any pair of actors and movies. (For the following, we will assume the
                existence of database structures and <code>DaoBuilder</code> objects for both
                entities.)</p>

                <p>
                    The backing table for storing associations should look like this:
                </p>

                <pre>
    create table actor_movie_associations (
        id integer primary key,
        movie_id integer,
        actor_id integer
    );</pre>
                <p>And there should be a sequence to populate the association IDs.</p>

                <p>To create an <code>AssociationDao</code>, we specify the <code>DaoBuilder</code>
                (or <code>Dao</code>) objects of the two entities and a few details about the
                association table. It looks like this:</p>

                <pre>
    DaoBuilder&lt;Actor&gt; actorDaoBuilder = // reference or creation
    DaoBuilder&lt;Movie&gt; movieDaoBuilder = // reference or creation

    AssociationDaoBuilder&lt;Actor, Movie&gt; actorMovieAssociationDaoBuilder =
            new AssociationDaoBuilder&lt;&gt;(actorDaoBuilder, movieDaoBuilder)
                    .withTableName("actor_movie_associations")
                    .withSequenceName("actor_movie_association_sequence")
                    .withPrimaryKeyName("id")
                    .withLeftColumnName("actor_id")
                    .withRightColumnName("movie_id");</pre>

                <p>All of the elements shown above must be set to make a valid <code>AssociationDaoBuilder</code>.
                    To create a <code>AssociationDao</code> from the builder just pass it a <code>Connection</code>.
                </p>
            </div>

            <a id="n_plus_one_queries"></a>
            <div class="card fluid">
                <h3>N+1 Queries</h3>
                <hr>

                <p>
                    When one entity has a parent child relationship with another, there are a number of ways
                    the child entities can be queried from the database. The most straightforward mechanism
                    is to query for the desired parent records and form them into a list. For each parent
                    record, a corresponding query is issued for matching child records which have a reference
                    back to the parent's primary key.
                </p>

                <p>
                    If N parent records are found by the initial query, there will follow N additional queries
                    for all the needed child records. This is the so-called N+1 query problem.
                </p>

                <p>
                    This is the default behavior of hrorm <code>Dao</code> objects.
                    Depending on the circumstances, it can result in poor performance when loading records.
                </p>

                <p>
                    Hrorm supports two alternate mechanisms for doing child selects. Both are variants of
                    constructing an in-clause when selecting for child records. Either mechanism can be
                    chosen by calling the <code>withChildSelectStrategy()</code> method on the
                    controlling <code>DaoBuilder</code>.
                </p>

                <h5>By Keys</h5>

                <p>
                    The by-keys strategy will generate SQL that selects child records matching an in-clause
                    that contains all the primary keys of the parent records found in the initial query.
                    The query will look something like this:
                </p>
<pre>
    SELECT * FROM CHILD WHERE PARENT_ID IN ( ?, ?, ?, ... )</pre>

                <p>A few problems may arise from generating queries in this style.</p>

                <ul>
                    <li>The in-clauses generated may overwhelm the underlying database's query parser.</li>
                    <li>Hrorm will generate a new prepared statement for each count of records found, which
                        may cause problems for the database's query optimizer or cache.</li>
                </ul>

                <h5>Sub-Select</h5>

                <p>Another strategy hrorm supports is to avoid constructing an explicit in-clause of IDs
                by issuing a sub-select for needed records. With this option, queries will look something
                like this:</p>

                <pre>
    SELECT * FROM CHILD WHERE PARENT_ID IN ( SELECT ID FROM PARENT WHERE .... )</pre>

                <p>The sub-select where clause will mirror the original query.</p>

                <p>This method also has potential pitfalls.</p>

                <ul>
                    <li>The where clause of the initial query will be run twice. It's possible that the
                    results might be as expensive to compute the second time as the first.</li>
                    <li>Entities that have children with their own children will issue queries
                        with recursively embedded sub-selects.</li>
                </ul>

                <div class="card fluid warning">
                    <b>Note.</b>An entity that selected because is connected to another entity by a join relationship will
                    always use the standard (N+1 queries) to load its children. The ChildSelectStrategy
                    for those entities will be ignored.
                </div>

            </div>


            <div class="card fluid">

                <a id="immutable_models"></a>
                <h3>Immutable Models</h3>

                <hr>

                <p>If you prefer that your Java entity model be made up of immutable classes, hrorm can support
                    that.</p>

                <p>Hrorm works well with immutable objects that have distinct builder classes for managing their
                    setters.
                    To allow this, hrorm provides an <a href="/javadocs/latest/org/hrorm/IndirectDaoBuilder.html"><code>IndirectDaoBuilder</code></a>
                    class. The indirect moniker is intended to suggest that the entities will not be directly
                    constructed,
                    but that will be handled by the builder objects.</p>

                <p>The following example uses lombok style builders, but you can roll your own if that's what you
                    prefer.</p>

                <pre>
    @lombok.Builder
    @lombok.Data
    public class ImmutableThing {
        private final Long id;
        private final String word;
        private final BigDecimal amount;
    }

    IndirectDaoBuilder&lt;ImmutableThing, ImmutableThing.ImmutableThingBuilder&gt; immutableThingDaoBuilder =
            new IndirectDaoBuilder&lt;&gt;("immutable_thing", ImmutableThing::builder, ImmutableThing.ImmutableThingBuilder::build)
            .withPrimaryKey("id", "immutable_thing_seq", ImmutableThing::getId, ImmutableThing.ImmutableThingBuilder::id)
            .withBigDecimalColumn("amount", ImmutableThing::getAmount, ImmutableThing.ImmutableThingBuilder::amount)
            .withStringColumn("word", ImmutableThing::getWord, ImmutableThing.ImmutableThingBuilder::word);

    Connection connection = // comes from somewhere

    // this returned object implements the identical interface as any other hrorm Dao
    Dao&lt;ImmutableThing&gt; immutableThingDao = immutableThingDaoBuilder.buildDao(connection);</pre>

                <p>It works very similarly to the regular <code>DaoBuilder</code>, but some extra details
                    are required. There are now two type parameters: one for the entity itself and
                    one for its builder object. On construction, instead of simply showing how to create
                    a new entity instance, two parameters show how to make a new builder instance and
                    how to make a new entity instance from the builder. Finally, all the setters are
                    specified on the builder class, not the entity instance.</p>

                <p>With a regular <code>Dao</code> the object's primary key will be set on
                    the object during the <code>insert()</code>. This is not true for <code>Dao</code>
                    objects created from an <code>IndirectDaoBuilder</code>. The <code>insert</code>
                    method will still return the newly issued ID.</p>

                <p>Indirect Dao objects support all the mechanisms for child and sibling records
                    that regular Dao objects do. Due to the lack of population of IDs, some care
                    must be taken. You cannot simply insert a sibling object and then
                    immediately place it into a new entity instance, since it will not yet
                    have its ID set.</p>

            </div>


            <div class="card fluid">

                <a id="keyless_entities"></a>
                <h3>Keyless Entities</h3>

                <hr>

                <p>Hrorm is built to support tables that have sequence valued primary keys. This is generally
                a good way to design a schema, but it's not always optimal. For instance, if you are storing
                an event stream in a database, assigning keys might just be a waste of time and space.</p>

                <p>Hrorm does have some mechanisms for supporting entities that do not have primary
                keys. But, you cannot create a full-featured <code>Dao</code> for an entity without
                a primary key. In these cases, you can create a <code>KeylessDao</code> by using the
                    <a href="/javadocs/latest/org/hrorm/IndirectKeylessDaoBuilder.html"><code>IndirectKeylessDaoBuilder</code></a>.
                A <code>KeylessDao</code> does not provide all the functionality that a <code>Dao</code> does.
                </p>

                <p>Another drawback to keyless entities is that they cannot be used as
                child or sibling entities. Hrorm manages all relationships via keys.</p>
            </div>

            <a id="constraints"></a>
            <div class="card fluid">
                <h3>Constraints</h3>
                <hr>

                <p>Hrorm provides some support for describing constraints on your entity models.
                    However, there is a limit to what hrorm can do: it is not the database or the
                    object model. If you wish to have constraint in the database, you need to put
                    them there, though hrorm can help with schema generation (see
                    <a href="#schema">below</a>). Additionally, invariants in your object model
                    need to be in your object model, not just in hrorm.</p>

                <p>The <code>DaoBuilder</code> allows you to mark particular columns as not null,
                    by calling the <code>notNull()</code> method.</p>

                <p>Where a not null condition is defined in hrorm, it will prevent the creation
                    of null entries in the particular field in question, either through inserts
                    or updates. However, hrorm will ignore the constraint when attempting load
                    records from the database, on the theory that loading questionable data is
                    better than not loading it.</p>

                <p>Hrorm also provides mechanisms for creating unique and foreign key constraints
                    in your schema, and is also discussed below.</p>

            </div>

            <a id="validation"></a>
            <div class="card fluid">
                <h3>Validation</h3>
                <hr>

                <p>Hrorm provides a <a href="/javadocs/latest/org/hrorm/Validator.html"><code>Validator</code></a> to
                    help in sure the database schema is in sync with the code.</p>

                <p>The validation provided is not a substitute for testing that code works as intended. It simply
                    checks that the names of the tables, columns, and sequences provided in the <code>Dao</code>
                    descriptions exist as stated. Columns are checked to make sure they are
                    of a correct type. As such, it can quickly find typos or other simple errors and
                    report them. This can be particularly useful in times of database refactoring.</p>

                <p>To check that a particular <code>Dao</code> is correct, simply pass it, or its builder,
                    to the <code>Validator::validate</code> method with a live <code>Connection</code>.
                    If the validation fails, an exception will be raised whose message describes the problems
                    found.</p>

                <pre>
    DaoBuilder&lt;Entity&gt; daoBuilder = new DaoBuilder&lt;&gt;("TABLE", Entity::new)
            .withPrimaryKey("id", "SEQUENCE", Entity::getId, Entity::setId)
            .withStringColumn("STRING_COL", Entity::getStringThing, Entity::setStringThing)
            .withLongColumn("INT_COL", Entity::getIntegerThing, Entity::setIntegerThing);

    Connection connection = // create connection just as for your application

    try {
        Validator.validate(connection, daoBuilder);
    } catch (HrormException ex){
        System.out.println(ex.getMessage);
    }</pre>

                <p>The testing that this performs is light. It will <b>not</b> attempt to make any changes to the
                    state of the database. It will merely check to make sure the structures exist as expected.
                    Moreover, each <code>Dao</code> is tested individually. Related <code>Dao</code>
                    objects, even dependent child objects, are not checked by the <code>Validator</code>.</p>

            </div>


            <a id="daos"></a>
            <h2>Daos</h2>
            <hr>

            <p>To create a <code>Dao</code> from a <code>DaoBuilder</code>, just pass it a
                <code>java.sql.Connection</code>:</p>

            <pre>
    // Assume the existence of some ConnectionPool
    Connection connection = ConnectionPool.connect();
    Dao&lt;Person&gt; dao = daoBuilder.buildDao(connection);</pre>

            <a id="insert"></a>
            <div class="card fluid">
                <h3>Insert</h3>
                <hr>

                <p>To create a new record in the database, we create a new instance of the class and pass it
                    to <code>Dao.insert()</code>.</p>

                <pre>
    Person person = new Person();
    // set values for the fields we want
    person.setName("Thomas Bartholomew Atkinson Wilberforce");
    person.setHighSchoolGraduate(true);
    person.setWeight(100L);
    long id = dao.insert(person);
    connection.commit();</pre>

                <p>After that code runs, the record will be stored in the database. Hrorm will have pulled
                    a new sequence value and set it on the object. The following assertions will be true. Note that for
                    immutable objects whose <code>Dao</code> implementations were created using an <code>IndirectDaoBuilder</code>
                    the ID will not be set.</p>

                <pre>
    Assert.assertNotNull(person.getId());
    Assert.assertTrue(id == person.getId());</pre>

                <h5>Children</h5>

                <p>Hrorm will automatically insert child records of the instance being saved, if any.</p>

                <h5>Siblings</h5>

                <p>If the record has sibling entities, references to those will be persisted. But be careful,
                    those sibling references must be persisted first. Sibling inserts and updates do not cascade.</p>

            </div>

            <a id="select"></a>
            <div class="card fluid">
                <h3>Select</h3>
                <hr>

                <p>Hrorm provides several methods for reading data out of the database and instantiating entity
                    objects.</p>

                <p>All of the selection mechanisms below will fully read and populate the entire relevant object graph
                    including all children and siblings and all their transitive references.</p>

                <p>
                    Hrorm provides overloaded <code>select()</code> and <code>selectOne()</code> methods.
                    All the various <code>select()</code> methods will return a <code>List</code> of all
                    the matching entities. The <code>selectOne()</code> method will return either null,
                    if no matches are found, a single instance if one database record is found, or throw
                    an exception if multiple matching records are found.
                </p>

                <h5>Primary Key</h5>

                <p>You can read an item from the database if you know its primary key.</p>

                <pre>
    Person person = dao.selectOne(432L);</pre>

                <p>If you want to read several IDs at once, you can.</p>

                <pre>
    List&lt;Person&gt; personList = dao.select(Arrays.asList(432L,21L,7659L));</pre>

                <h5>All Records</h5>

                <p>If you want all the records (presumably for a smallish table) just do</p>

                <pre>
    List&lt;Person&gt; personList = dao.select();</pre>

                <h5>By Columns</h5>

                <p>
                    Most of the time, you do not know up front what ID or IDs you are interested in, so
                    hrorm provides ways to specify which records you are interested in.
                    One way is by using hrorm's ability to select by columns.
                    The idea of this interface is to use an instance of the entity class as a template
                    or key for providing the values you want to match.
                    Suppose we want to find all the records of people who are high school graduates and
                    weigh 100. Create an instance of the <code>Person</code> object with those fields
                    set, as follows.
                </p>

                <pre>
    Person personTemplate = new Person();
    personTemplate.setHighSchoolGraduate(true);
    personTemplate.setWeight(100L);</pre>

                <p>Then, we can find the matching records by passing that object and the names of the
                    columns to filter on.</p>

                <pre>
    List&lt;Person&gt; people = personDao.select(personTemplate, "IS_HIGH_SCHOOL_GRADUATE", "WEIGHT");</pre>

                <p>Notice that hrorm wants the names of the database <b>columns</b>, not the fields on the object.</p>

                <p>If a particular query will only return 0 or 1 results, hrorm provides a convenience method for that.</p>

                <pre>
    Person personTemplate = new Person();
    personTemplate.setName("Rumpelstiltskin");

    Person person = personDao.selectOne(personTemplate, "NAME");</pre>

                <h5>Where objects</h5>

                <p>The templating method above can be useful, but is not the most generic mechanism provided by
                hrorm. To support a variety of predicates hrorm provides a <code>Where</code> object that allows
                construction of more complex filters than the exact matching of object fields.</p>

                <p>
                    A <code>Where</code> object is a collection of predicates, possibly nested, joined by
                    the conjunctions AND and OR. A predicate is the name of a column, an operator, and a value.
                    To find all the people who are high school graduates who weigh 100, as above, set up
                    a where object like this:
                </p>

                <pre>
    Where where = new Where("IS_HIGH_SCHOOL_GRADUATE", Operator.EQUALS, true);
    where.and("WEIGHT", Operator.EQUALS, 100L);</pre>

                <p>Then we can pass that to the select method to get the results.</p>

                <p>Various operators are supported, not just equality. So we can now find all
                the people whose names are like Mark and weigh between 75 and 125, as follows.</p>

                <pre>
    Where where = new Where("NAME", Operator.LIKE, "%Mark%");
    where.and("WEIGHT", Operator.GREATER_THAN, 75L);
    where.and("WEIGHT", Operator.LESS_THAN, 125L);</pre>

                <p>We can also nest <code>Where</code> objects, like so:</p>

                <pre>
    Where where = new Where("NAME", Operator.LIKE, "%Mark%");
    Where weightCheck = new Where("WEIGHT", Operator.GREATER_THAN, 75L);
    weightCheck.and("WEIGHT", Operator.LESS_THAN, 125L);
    where.or(weightCheck);</pre>

                <p>This will generate SQL to find anyone who has a name that matches "Mark" <em>or</em> weighs
                between 75 and 125.</p>

                <p>By using static imports, we can rewrite the above as follows:</p>

                <pre>
    List&lt;Person&gt; records = dao.select(where("NAME", LIKE, "%Mark%")
                                              .or(where("WEIGHT", GREATER_THAN, 75L)
                                                   .and("WEIGHT", LESS_THAN, 125L));</pre>

                <p>Which some people may find more readable.</p>

                <p>Check the Javadocs for a complete list of supported operations. Note that to generate
                SQL for <code>IS NULL</code> and <code>IN</code> (and their negations) you directly
                call methods on the <code>Where</code> class. There are not instances of the
                <code>Operator</code> class for those facilities.</p>

                <p>Building where clauses can be a bit tricky. The <code>render()</code>
                method exports the actual SQL that will be generated by hrorm at run time.</p>

                <h5>Sorting</h5>

                <p>Select methods that return a list of results are overloaded to allow passing
                    an <a href="/javadocs/latest/org/hrorm/Order.html"><code>Order</code></a> object.</p>

                <p>Including and <code>Order</code> object will result in SQL with an <code>ORDER BY</code>
                added, including the column names you provide.</p>

                <p>Of course, the ordering applied by the database may be different than that applied
                by Java.</p>

                <h5>Distinct</h5>

                <p>
                    The overloaded <code>selectDistinct()</code> method provides a mechanism for providing
                    distinct values from the database. There are variants for selecting distinct single values,
                    two-tuples, and three-tuples. The methods accept the name(s) of the database columns to select
                    distinct values from. The returned results will have the types of the object model specified
                    in the <code>Dao</code>, i.e. any <code>Converter</code> that was specified will be applied.
                </p>

            </div>

            <a id="update"></a>
            <div class="card fluid">
                <h3>Update</h3>
                <hr>

                <p>After making changes to the state of the object, we can call</p>

                <pre>
    dao.update(person);
    connection.commit();</pre>

                <p>This will issue an update in the database based on the primary key (<code>id</code>) field.</p>

                <p>Updates will automatically propagate to children, but not to siblings.</p>

            </div>

            <a id="delete"></a>
            <div class="card fluid">
                <h3>Delete</h3>
                <hr>

                <p>When we are done with a person, we can issue</p>

                <pre>
    dao.delete(person);
    connection.commit();</pre>

                <p>To remove the record from the database, using the primary key, as with an update.</p>

                <p>Deletes will automatically propagate to children, but not to siblings.</p>

            </div>

            <a id="association_daos"></a>
            <div class="card fluid">
                <h3>Association DAOs</h3>
                <hr>

                <p>As mentioned <a href="#association_relations">above</a>, <code>AssociationDao</code>
                objects are a completely distinct interface from <code>Dao</code> objects. There are only
                a handful of supported operations.</p>

                <h5>Insert</h5>
                <p>Assuming we have two entities, a <code>Movie</code> and an actor <code>Actor</code>
                and we have built the association, we can create new ones as follows:</p>

                <pre>
    Connection connection = // made this from JDBC
    AssociationDao&lt;Actor, Movie&gt; associationDao = associationDaoBuilder.buildDao(connection);
    Movie legallyBlonde = // a persisted movie
    Actor reeseWitherspoon = // a persisted actor

    associationDao.insert(reeseWitherspoon, legallyBlonde);

    connection.commit();</pre>

                <h5>Delete</h5>

                <p>If a connection needs to be removed, we use the <code>delete()</code> method.</p>

                <pre>
    Actor laurenceOlivier = // another actor
    associationDao.delete(laurenceOlivier, legallyBlonde);</pre>

                <h5>Selects</h5>

                <p>Associations work in both directions, but we have to take care with which type was
                on the left and which was on the right. (This has nothing to do with left or right joins,
                just the names for the two types being associated.)</p>

                <pre>
    List&lt;Actor&gt; cast = associationDao.selectLeftAssociates(legallyBlonde);
    List&lt;Movie&gt; career = associationDao.selectRightAssociates(reeseWitherspoon);</pre>

                <p>That's all there is to it.</p>

            </div>



            <a id="functions"></a>
            <div class="card fluid">
                <h3>Functions</h3>
                <hr>

                <p><code>Dao</code> objects provide the ability to run some SQL functions against
                the database records. All the supported functions are single column aggregations,
                like COUNT, SUM, AVG, etc.</p>

                <p>To use them is simple, just pass the name of the function and the column you
                are interested in to the appropriate run method. The functions can be run using
                the same <code>Where</code> objects as can be used for selects. To find the maximum
                weight of everyone named "Mark" who is a high school graduate, we would run:</p>

                <pre>
    Long maximumMarkWeight = dao.runLongFunction(SqlFunction.MAX, "WEIGHT",
                                    where("NAME", Operator.LIKE, "%MARK%")
                                      .and("IS_HIGH_SCHOOL_GRADUATE", Operator.EQUALS, true));</pre>

                <p>See the <a href="http://localhost/javadocs/latest/org/hrorm/SqlFunction.html"><code>SqlFunction</code></a>
                    for the list of supported functions.</p>
            </div>


            <a id="atomic"></a>
            <div class="card fluid">
                <h3>Atomic</h3>
                <hr>

                <p>In addition to the <code>insert</code>, <code>update</code>, and <code>delete</code>
                    methods, hrorm <code>Dao</code> objects provide variants of those methods
                    called <code>atomicInsert</code>, <code>atomicUpdate</code>, and <code>atomicDelete</code>.
                    These are useful if you do not mind your changes being committed automatically. But they
                    cannot be used inside larger transactions. Additionally, these methods will close the
                    <code>Connection</code> object their enclosing <code>Dao</code> was built with.</p>

            </div>

            <a id="folding"></a>
            <div class="card fluid">
                <h3>Folding</h3>
                <hr>

                <p>Many ORMs (and other database connectivity tools) provide some mechanism for lazily
                    loading data. This is a useful feature since it's quite common to work on data sets
                    in your application that are too large for it.
                </p>

                <p>The biggest problem with this approach is that it can lead to peculiar bugs when
                    a connection is closed too early and something that was to be lazily loaded cannot be.
                </p>

                <p>
                    Hrorm's select methods are not lazy and so are only suitable for selecting limited
                    quantities of data. But, Hrorm does provide a way to run a select without instantiating
                    a list of all the found objects with the
                    <a href="/javadocs/latest/org/hrorm/KeylessDao.html#foldingSelect-T-java.util.function.BiFunction-org.hrorm.Where-"><code>foldingSelect()</code></a> method.
                    This method allows a general select to be done, and then a flexible folding operation
                    to take place on the database's returned result set.
                </p>

                <p>At times, it might be more sensible to write the logic required as a select with a
                    group by clause. But at other times you cannot express the application logic necessary
                    in the database, and this facility exists for those times.
                </p>

                <p>If you're unfamiliar with folding, here are some quick examples which show how it
                can be used. If you have an entity that exposes a long value and you wish to know
                the sum of all those values, you could write:</p>

                <pre>
    Long result = dao.foldingSelect(0L,
                                    (accumulator, entity) -> accumulator+entity.getLongValue(),
                                    new Where());</pre>

                <p>Which would be equivalent to writing:</p>

                <pre>
    Long result = dao.runLongFunction(SqlFunction.SUM, "LONG_COLUMN", new Where());</pre>

                <p>Another example shows how to build up a list of items.</p>

                <pre>
    List&lt;Entity&gt; entities = dao.foldingSelect(new ArrayList&lt;&gt;(),
                                                    (list, entity) -> list.add(entity),
                                                    new Where());</pre>
                <p>Which is equivalent to:</p>

                <pre>
    List&lt;Entity&gt; entities = dao.select(new Where());</pre>

                <p>These two examples are a bit silly, and clearly the alternatives are better. But, folding
                allows you to define an arbitrary accumulation function on whatever type you wish,
                    not just adding sums or appending to lists.</p>

            </div>


            <a id="sql"></a>
            <div class="card fluid">
                <h3>SQL</h3>
                <hr>

                <p>The <code>SQL</code> that hrorm generates to make a <code>Dao</code> can be accessed by
                    calling the <code>queries()</code> method. The <code>SQL</code> is formatted
                    in a way suitable for passing to a <code>PreparedStatement</code> with embedded
                    question marks for variable substitution.</p>

                <p>You can also access a <code>Queries</code> object by calling <code>buildQueries()</code>
                    on a <code>DaoBuilder</code> object. This provides an identical instance, but does not
                    require a <code>Connection</code>, which building a <code>Dao</code> does.</p>

            </div>


            <a id="miscellaneous"></a>
            <h2>Miscellaneous</h2>
            <hr>

            <div class="card fluid">

                <a id="dates_and_times"></a>
                <h3>Dates and Times</h3>
                <hr>

                <p>
                    Storing dates and times is important to many applications. Hrorm of course tries to
                    support this endeavor, but user caution is advised.
                </p>

                <p>
                    Databases support a myriad varieties of dates and times, but the oldest and most
                    established is the time zone free timestamp, which generally is some amount of time
                    offset from some zero point. (Number of seconds, including fractional amounts, since
                    00:00:00 1-Jan-1970 or something.) What this means to you might vary.
                </p>

                <p>
                    The JDBC supports the timestamp concept above through the type <code>java.sql.Timestamp</code>,
                    which is implemented as an extension of the widely hated (and mostly deprecated)
                    <code>java.util.Date</code>. One reason (among many) that people dislike the <code>java.util.Date</code>
                    type is because it isn't even a date. It's a date and time. Except it's not that, it's a timestamp,
                    an offset from the epoch as above. So, already we are in trouble, since the primary means of
                    persisting date and time information of all sorts is through a mutable type of
                    deprecated methods of confusing meaning difficult to translate to the very good options
                    available in the <code>java.time</code> package.
                </p>

                <p>
                    For a tool like hrorm, the most important thing is to expose functionality to the user
                    in a very general way. As always, the hrorm philosophy is
                    to not try to be all things to all people, since the peculiarities of your needs and
                    the underlying database capabilities are so diverse, it's better to just get out of the way.
                    That said, for most of what you need dates and times for, timestamps work just fine, given
                    some care. Yes, if you're just storing a date in your model, there's some precision you do
                    not need, but so what? And if you want to make sure you remember what time zone or offset
                    from UTC you need to attach to a persisted timestamp, you can use another column for that.
                    Or, if your application always does things one way, you can hard code logic for conversions.
                </p>

                <p>
                    The <code>java.sql.Timestamp</code> was retrofitted with converters to and from two
                    concrete classes of the <code>java.time</code> package, <code>Instant</code> and
                    <code>LocalDateTime</code>. For a more modern framework like Hrorm, those are the
                    only two real contenders for what to expose on its interfaces.
                </p>

                <p>
                    <code>LocalDateTime</code> is probably more useful for most applications. It has obvious
                    ways to access information like day of the week or hour of the day that are not directly
                    available from an <code>Instant</code>. It's probably the go to choice when modeling domain classes
                    that involve date time values. With the caveat that if all you want is a date (or a time)
                    you can use a smaller more focused type.
                </p>

                <p>
                    Nevertheless, Hrorm chooses to expose <code>java.time.Instant</code>. Why?
                    Because it creates better guarantees about storing the values you give it
                    and being able to recover them. Consider the following sad example.
                </p>

                <pre>
    int year = 2018;
    int month = 3;
    int day = 11;
    int hour = 2;
    int minute = 0;
    int second = 0;
    int nanos = 0;

    LocalDateTime localDateTime = LocalDateTime.of(year, month, day, hour, minute, second, nanos);
    Assert.assertEquals(2, localDateTime.getHour());
    Timestamp timestamp = Timestamp.valueOf(localDateTime);
    Assert.assertEquals(3, timestamp.getHours());
    LocalDateTime recoveredLocalDateTIme = timestamp.toLocalDateTime();
    Assert.assertEquals(3, recoveredLocalDateTIme.getHour());</pre>

                <p>
                    Leaving aside that the getHours() call is deprecated on <code>Timestamp</code>,
                    on my computer and JVM, which is in the "America/Chicago" time zone, the
                    above tests all pass. (On my computer, but maybe not on yours!)
                    So, the time you thought you were putting into the
                    database is not the time you will get out.
                </p>

                <p>
                    What's happening? The time initially created does not really exist: at that
                    precise moment, the clocks sprang forward in "America/Chicago" and we
                    never had a 2AM on 11 March 2018. Despite neither of the classes involved
                    having a time zone component, conversion between them implicitly uses a
                    time zone, and changes the hour. It's perhaps unfortunate that the
                    <code>LocalDateTime</code> allows construction of what is perhaps an illegal
                    instance, but it's not an illegal instance until it's combined with a time
                    zone. For all it knew at construction time, I was talking about that time
                    in some other time zone. (Perhaps the word "Local" was a bad choice. It means
                    local to somewhere, not local to where you happen to be. Maybe they should have
                    called in "<code>UnzonedDateTime</code>"?)
                </p>

                <p>
                    The <code>Instant</code> conversions have no such problem, but of course,
                    you have to be careful when your model converts from a date type to an instant
                    type, since pitfalls exist. (Again, the following tests all pass on my computer,
                    but perhaps not on yours!)
                </p>

                <pre>
    int year = 2018;
    int month = 3;
    int day = 11;
    int hour = 2;
    int minute = 0;
    int second = 0;
    int nanos = 0;

    LocalDateTime localDateTime = LocalDateTime.of(year, month, day, hour, minute, second, nanos);
    Assert.assertEquals(2, localDateTime.getHour());
    Instant instant = Instant.from(ZonedDateTime.of(localDateTime, ZoneId.systemDefault()));
    LocalDateTime recoveredLocalDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
    Assert.assertEquals(3, recoveredLocalDateTime.getHour());</pre>

                <p>
                    What hour does the <code>Instant</code> show? The question makes no sense: an
                    instant only has an hour within the context of a particular time zone.
                </p>

                <p>
                    So, Hrorm tries to follow it's philosophy as best it can: there is a problematic
                    issue exposed, but it's up to the client code to solve it. But at least what hrorm
                    does is predictable, the <code>Instant</code> you choose to store will be
                    the <code>Instant</code> that is returned to you.
                </p>
            </div>

            <div class="card fluid">

                <a id="schema"></a>
                <h3>Schema</h3>
                <hr>

                <p>
                    Hrorm provides a mechanism for generating your database schema through its
                    <code>Schema</code> object. Using it is simple. Pass your <code>DaoBuilder</code>
                    objects to the <code>Schema</code> constructor and call the <code>sql()</code>
                    method to get a SQL <code>String</code> that generates the schema backing your
                    model. The hrorm generated schema will include:
                </p>

                <ul>
                    <li>Sequence definitions</li>
                    <li>Table definitions</li>
                    <li>Constraints: both foreign keys for join and parent columns as well as uniqueness constraints
                    you have defined</li>
                </ul>

                <p>
                    There are good reasons not to use the schema generated by Hrorm for your actual
                    database. For instance, by default the SQL Hrorm generates uses lowest common denominator
                    types for columns, though this can be overridden. Probably more important is that
                    your schema should be in version control itself, independent of the dynamically
                    generated schema that hrorm can provide.
                </p>

                <p>
                    Nevertheless, this can be a helpful feature. If your schema is under version
                    control in a separate system from your code, it might be helpful for running
                    tests. If you are doing development and rapidly changing schema, it can save
                    you the trouble of writing and changing the SQL in tune with your object model.
                    And you can always use the SQL Hrorm generates as a starting point, adding
                    whatever refinements you require by hand.
                </p>

                <p>
                    If you do wish to use hrorm to generate schema, make sure to take advantage of
                    the following schema-specific features.
                </p>

                <ul>
                    <li><b>Nulls</b> - Using the <code>notNull()</code> method you can make sure
                    generated schema marks columns as not null.</li>
                    <li><b>Unique Constraints</b> - Hrorm will generate foreign key constraints
                    for parent and join columns, but you must tell it about any uniqueness constraints
                    by calling the <code>withUniqueConstraint()</code> method on your DAO builder
                    objects.</li>
                    <li><b>SQL Types</b> - By default hrorm will use common ANSI types like <code>TEXT</code>
                    and <code>INTEGER</code> for columns. If you wish to specify more exact types, you
                    can use the <code>setSqlTypeName()</code> method on your DAO builders, allowing
                    you to set arbitrary types in the generated schema.</li>
                </ul>

            </div>

            <div class="card fluid">

                <a id="exceptions"></a>
                <h3>Exceptions</h3>
                <hr>

                <p>Hrorm thinks that checked exceptions are a mistake. In an application with a database dependency,
                    you have three choices:</p>

                <ol>
                    <li>Have <code>SQLException</code> declared in most methods all over your application.</li>
                    <li>Try to handle <code>SQLException</code> somehow when doing interactions with
                        <code>Connection</code>,
                        <code>Statement</code>, and <code>ResultSet</code> objects, defeating the purpose of
                        exception handling being centralized and removed from normal application flow.
                    </li>
                    <li>Convert <code>SQLException</code> to some other type, descended from
                        <code>RuntimeException</code>.
                    </li>
                </ol>

                <p>
                    Hrorm opts for method 3.
                </p>

                <p>Hrorm will throw a <code>HrormException</code> when it has a problem. If there was an underlying
                    <code>SQLException</code> that will be exposed on the <code>HrormException</code>.
                </p>

            </div>


            <div class="card fluid">

                <a id="logging"></a>
                <h3>Logging</h3>

                <hr>

                <p>The state of Java logging is a tiny bit unfortunate.</p>

                <p>The <code>java.util.logging</code> package in the standard library is not widely
                    used. Unfortunately, rather than a set of pluggable interfaces, they provided a concrete
                    implementation.</p>

                <p>Log4j is pretty ubiquitous, but not universal. Additionally, hrorm currently has
                    no dependencies. It would be a shame to add one.</p>

                <p>Hrorm therefore uses <code>java.util.logging</code> implementation.
                    There are ways to redirect that to log4j and other logging frameworks.</p>

                <p>Hrorm logs to a logger named "org.hrorm" all the SQL it issues at INFO level.</p>

            </div>

            <div class="card fluid">

                <a id="visibility"></a>
                <h3>Visibility</h3>

                <hr>

                <p>Hrorm is designed to have a small surface area for clients. Most of the time, clients should only
                    need to interact with a few hrorm types: <code>DaoBuilder</code>, <code>Dao</code>,
                    <code>Where</code>, <code>HrormException</code>, and perhaps a few others.
                    There are a few other types that a client may want to use,
                    but many of the classes in hrorm are internal to it.

                <p>In spite of this, almost all the classes in hrorm are public and contain public constructors
                    and methods. If you feel like instantiating a <code>JoinColumn</code> object, hrorm feels
                    no need to try to stop you.</p>

                <p>Most of the time, hrorm will point out in the Javadocs where classes are not
                    intended for clients to use directly.</p>

            </div>

        </div>

    </div>
</div>

</body>
</html>
