<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Chapter 3</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.0/mini-default.min.css">
</head>

<body>

<p>
    We are spoiled in the Java world. For almost any programming task you
    can imagine there are many freely available, open source projects you
    can choose from.
    If I was a programmer manager and my team came to me and suggested that
    we write our own ORM framework, I would send them home and tell them to
    come back when they sobered up.
    Nevertheless, when I was working on a personal project beginning last
    year, I could not find what I wanted, and so I began <a href="https://hrorm.org">hrorm</a>.
    I've written some articles about hrorm (for example,
    <a href="https://dzone.com/articles/introducing-hrorm-a-simple-declarative-type-checke">here</a>)
    that describe some aspects of hrorm. In this article, I want to talk about some
    of the choices I faced in writing hrorm, and why I made some of the choices
    I did.
</p>

<h3>Libraries and Frameworks</h3>

<p>
    As an application developer I prefer libraries to frameworks. I won't try to formally
    distinguish between the two, but I think most programmers have some idea about
    the distinction I am making. Libraries are imported by putting a jar file
    in your classpath; they provide clients with classes and methods; they define interfaces
    and then provide implementations of them. Frameworks require set-up and
    configuration and containers; they have interfaces they expect clients to
    to implement; they start up threads and start doing work before you even call
    them.
</p>

<p>
    Frameworks can deliver big bang for the buck of course. With very little
    programming work (but rather a lot of research and learning work) frameworks
    can allow small teams of developers to build big applications quickly. But it
    comes with a cost. Frameworks can be magical, but magical can mean unpredictable,
    hard to debug, have confusing performance characteristics, and can make seemingly
    simple things incredibly frustrating, if the authors have not anticipated your
    particular needs.
    That's perhaps unfair, and many frameworks are terrific, but I like using libraries
    better. If something is going to venture into framework territory, it better give
    me something very valuable for the added complexity they bring.
</p>

<p>
    The paradigmatic example in my mind of a library is something like the apache
    or guava collections. A bunch of classes you can use (or not) by just putting
    a jar file in your classpath. No configuration or set-up needed. And the library
    just does what you ask of it. If you don't create instances of the classes or
    call their methods, it doesn't require a bunch of set-up or run threads in your
    application. And when you encounter a problem the stack traces make sense, they
    don't flood your screen with lines of ConfigurationManagerProviderImplementationDirector
    objects doing reflection.
</p>

<h3>Cleverness</h3>

<p>
    One of my favorite programming aphorisms is Brian Kernighan's comment on debugging:
    "Debugging is twice as hard as writing the code in the first place.
    Therefore, if you write the code as cleverly as possible, you are,
    by definition, not smart enough to debug it." My corollary to his theorem is
    that you are twice as stupid at two in the morning when called by the operations
    team than you are during the work day. And therefore, if you have to debug
    clever code at two in the morning, you are 4 times stupider than you need to be.
</p>

<p>
    Hrorm is not a library that is built to impress when you are fully caffeinated and
    relaxing in the post-doughnut mid-morning surfing session on your dual 30 inch
    monitors. It's built for the dead of night when you're trying to sleep one off
    and you don't want to figure out why a lazy sequence cannot be realized, why
    all the threads in the thread pool are simultaneously busy-waiting, or
    why a cache has over a billion entries when there are only a total of a million
    records in the database.
</p>

<p>
    When you call one of hrorm's methods, it does something pretty simple. It generates
    some SQL, it passes it along a <code>Connection</code>, and it parses the results
    into your object model, calling methods that you defined.
</p>




<p>
    When I started a new project last year, I could not find what I wanted.
</p>

<ul>
    <li>SQL generation</li>
    <li>Declarative, type-checked API</li>
    <li>Simple API for CRUD operations directly on my object model</li>
</ul>

<p>
    And a list of things I did not want.
</p>

<ul>
    <li>External configuration or containers</li>
    <li>Caching, threading, or laziness</li>
    <li>Reflection, unsafe code</li>
</ul>

<p>
    There are probably seven libraries out there that could have sufficed, but
    I started writing my own persistence layer for my project, and that
    became a library, and that became Hrorm.
</p>

<p>
    Building a library for public release makes you think about some design
    questions.
</p>

<h3>The Work of Persistence</h3>

<p>
    To manage the persistence of objects in an RDBMS requires doing a few things.
</p>

<ul>
    <li>Decomposing an object into its atoms (strings, numbers, timestamps, etc)</li>
    <li>Generating SQL statements</li>
    <li>Taking the decomposed parts and inserting them into the SQL</li>
    <li>Parsing results from the database</li>
    <li>Recomposing objects from their constituents</li>
</ul>

<p>
    Composing and decomposing objects can be done using getters and setters,
    or builder objects in the case of immutable models. SQL can be easily
    created through simple string manipulation, since there is a limited
    universe of statements to create, and generation is so much simpler
    than parsing. The biggest challenge in parsing result sets is making
    sure to correctly alias and prefix column names when doing joins.
    Mostly, the tasks of doing persistence are a matter of careful accounting
    rather than clever programming.
</p>

<p>
    There's a bit of a hidden problem that is only referenced above: classes
    are not just made of atomic parts that directly decompose into atomic parts.
    They are made up of other objects. But really, this mostly adds another
    layer of accounting. It's not like things suddenly went NP on us.
</p>

<h3>Meta-Programming</h3>

<p>
    Some languages (Lisps, Ocaml, Ruby) embrace meta-progmramming. Others have more
    grudging support (C with it's macros). Others are a bit schizoophrenic (Haskell
    versus Template Haskell). I would put Java in the grudging support category.
    Reflection exists, and has for a long time. But it's clumsy and leads to code
    that is unexpressive and unintuitive.
</p>

<p>
    For certain kinds of libraries, reflection is an essential part of the architecture.
    Many go further and use <code>sun.misc.Unsafe</code>. I get nervous when my tools are
    using the features of unsafe. I want my objects to be constructed using my methods, so
    that the invariants I establish are obeyed. It's nothing to worry too much over, but
    I prefer to stick with simpler code.
</p>

<p>
    Fortunately, since Java 8, and the introduction of things that look like function
    pointers, just using the language without any meta-programming got a lot easier.
</p>



<h3>Libraries and Applications</h3>

<p>
    Generalizing wildly, there are two kinds of programmers: those that work on applications
    and those that work on libraries. Application developers' work will be judged overwhelmingly
    by application users on one criteria: does the application do what I want it to reliably
    and without undue fuss. Library writers are judged by muddier criteria. Clearly, some
    libraries become more popular than others (just as some applications do, and I would not
    say that an application's popularity is strictly proportional to its quality), but when
    programmers pick a library, they weigh more criteria more heavily than application consumers do.
    What are they looking for?
</p>

<h3>Ease of use versus ease of implementation</h3>

<p>
    When I wrote hrorm, it was very important to me that users (like me) be able to write code
    like this:
</p>

<pre>
DaoBuilder&lt;Item&gt; = new DaoBuilder&lt;&gt;("item_table",Item::new)
        .withPrimaryKey( ... )
        .withStringColumn( ... );</pre>

<p>
    What are the implications of that requirement, from a Java language perspective?
    First of all, it means <code>DaoBuilder</code> cannot be an interface or an abstract
    class. The code instantiates an instance of one, so it has to be an object. This is in
    no way a functional requirement on hrorm, and it's easy to imagine a way that it could
    be different: <code>DaoBuilder</code> could be an interface, and you could instantiate
    a <code>SimpleDaoBuilder</code>, or numerous other alternatives. But it was very important
    to me that it work exactly as shown. Partly because I think it makes looking at hrorm
    for the very first time easier. Partly just because I think it reads better. But there's
    a bigger issue lurking: if <code>DaoBuilder</code> is an interface, and there are
    multiple implementations (and eventually, hrorm came to support more than one way to
    build a <code>Dao</code>), the different implementations cannot support different methods
    and still provide a fluent interface: each <code>withSomething()</code> method will
    return the lowest common denominator interface type, and then users can only call methods
    on that interface, not any specialty methods the different implementations provide.
</p>

<p>
    Because of this, the multiple mechanisms for building a <code>Dao</code> in hrorm are
    largely independent, with a lot of cut-and-pasted code and documentation that is
    irritating and error prone to maintain.
</p>

<p>
    We can perhaps imagine some new language (let's call it Jaskell) that gets around this
    problem that allows us to write code like this:
</p>

<pre>
interface DaoBuilder&lt;T&gt; a {
    buildDao : a -> Connection -> T;
    withColumn : a -> String -> (T -> String) -> (T -> String -> ()) -> a;
}</pre>

<p>
    I won't bother to explain what that might mean, since it's both theoretical and a monstrosity.
    And beside the point anyway, since this whole issue is self-imposed. If I could let go
    of the unimportant requirement that a user's first exposure to hrorm look exactly one
    particular way, the code could be simplified. But somehow, I have in my mind the declarative,
    fluent interface that hrorm provides. As long as I want to provide that, I am stuck with
    maintaining the code as it is. My hope is that the ease-of-use for clients outweighs the
    annoyance of implementation to me and other hrorm contributors.
</p>

<h3>More on the type checker</h3>

<p>
    To use hrorm, the application developer must provide it with two things: information
    about the Java object model and data about the SQL schema. The object model is clearly
    the easier one for hrorm to deal with: it's in hrorm's language. The SQL schema is not,
    it's just a bunch of strings.
</p>

<p>
    That's annoying for users since you would like to define the name of the column once,
    just as you define a constant once, and then always have the benefit of the compiler
    to make sure you are refering to it correctly. (You can just make constants for all
    your column names, of course, but now you're doing extra work, not having work
    done for you.) The reason you want to refer to columns more than once is in building
    where clauses, like this.
</p>

<pre>
    Dao&lt;Item&gt; dao = // comes from something
    List&lt;Item&gt; = dao.select(where("COLUMN_A", EQUALS, "Foo")
                                   .and("COLUMN_B" GREATER_THAN, 7L));</pre>

<p>
    There are really two problems here. The first is that the name of the column might
    be wrong: "COLUMNA" instead of "COLUMN_A". The second is that the type of the
    column might be wrong: using an illegal comparison, like comparing a string to an
    integer. When creating a hrorm <code>Dao</code>, the user has already defined
    the name and something about the type of the column, it would be nice to make
    use of it, but I do not see how, except by some form of code generation which
    adds a huge overhead to using hrorm.
</p>

<p>
    Hrorm does use one trick to somewhat mitigate the type problem, though not
    the mis-spelled column name problem. It has methods to select that are based
    on passing an instance of the object itself to the method on the DAO. An object
    is initialized with some of its values set, and a list of objects is returned
    that match the specified values on the specified columns. That way, the types
    of the values have to be correct, and of the types that hrorm knows about,
    but of course, the column names can still be wrong.
</p>

<hr>

<p>
    TOPICS:
    * Dao builder: interface clarity versus sharing code, problems with inheritance
    * Dependencies and logging
    * Frameworks versus libraries
    * meta-programming, annotations and reflection (unsafe)
    * lack of type-checking for where clauses
    * Lack of optimization (Hrorm is really slow)
    * packages/namespacing
    * What basic Java types are supported
    * Jobs to do:
        * Generate SQL - should be efficient (i.e. joins)
        * Build objects from result sets
        * Manage resources properly, closing things
</p>

<h3>Laziness</h3>

<p>
    Hrorm is pretty simple. If you call a <code>select()</code> method on a
    hrorm <code>Dao&lt;T&gt;</code> object, you get a fully-realized, eagerly
    created <code>List&lt;T&gt;</code>. There are plenty of times when that
    works fine, but not always.
</p>

<p>
    One of hrorm's contributors has suggested that hrorm include a lazy loading,
    <code>java.util.stream.Stream</code> style interface. The utility of such an
    interface is easy to see. When doing an operation on items read from the
    database, you might not wish to have all the objects you plan to operate
    on resident in memory simultaneously. A method that returned <code>Stream&lt;Entity&gt;</code>
    could be backed by a <code>javax.sql.Connection</code> that read only some
    small number of items at a time, as required by running program. One the
    stream was exhausted, and the calculation complete, closing the <code>Stream</code>
    could automatically close the <code>Connection</code>. It's a very reasonable
    design to solve a real problem. So, why have I resisted it?
</p>

<p>
    The <code>Stream</code> API is a powerful and worthwhile addition to the language.
    I myself find that I mostly use it for cases like this:
</p>

<pre>
    List&lt;Foo&gt; foos = someFunctionThatGetsTheFoos();
    List&lt;Bar&gt; bars = foos.stream().map(transformationFunction).collect(Collectors.toList());
</pre>

<p>
    That's a good improvement from the older days of Java, but really for those cases,
    I would just like <code>List</code> to implement <code>map</code> directly, it would
    save some noisy characters in the code. The problem is that Java's type system does
    not really have a way to express an ML-style functor: a container that preserves its
    own character, while modifying the contents.
</p>

<p>
    Even though there's a lot of code that looks like the above in the world, that's not
    really what <code>Stream</code> is for. To quote the Javadocs, a <code>Stream</code>
    is "A sequence of elements supporting sequential and parallel aggregate operations."
    That sounds somewhat like what we want in the lazy sequence of database elements, but
    there are some mismatches.
</p>

<p>
    First of all, it's not going to support parallel operations. A <code>Connection</code>
    backed <code>Stream</code> will only support sequential operations. A good use for
    <code>Stream</code> is when we want to write some processing code that is impervious
    to how the underlying <code>Stream</code> works, so when appropriate, parallel operations
    can be performed transparently. This is certainly not the impression we want to leave
    the user with.
</p>

<p>
    Instead, hrorm provides a method, <code>foldingSelect</code> that accomplishes more
    or less the same thing as a <code>Stream</code> API would: the user can write a function
    that folds over the result set, accumulating a result while never realizing all the
    data from the database simultaneously.
</p>

<p>
    Perhaps none of that is very convincing to you, so how about an example of what can go wrong?
    (Showing some code that looks like hrorm, but uses a method that does not actually
    exist.)
</p>

<pre>
    try {
        Connection connection = connectionFactory.get();
        Dao&lt;Foo&gt; fooDao = fooDaoBuilder.buildDao(connection);
        // this method does not exist
        Stream&lt;Foo&gt; fooStream = fooDao.lazySelect();
    } catch(HrormException ex){
        // hrorm wraps all database errors with its own extension of RuntimeException
        handleDatabaseProblems(ex);
    }
    processStream(fooStream);
</pre>

<p>
    That code has a problem that many readers probably noticed: the <code>processStream()</code>
    method should be inside the try-catch block, since it still uses the <code>Connection</code>
    and can throw database exceptions. And now the reader might object: sure, that's a problem,
    but people understand how live database streams work, and the docs can explain it, etc. Only
    a noob would make an error like that.
</p>

<p>
    My answer is two parts. One is that I would rather write a library that is hard to use
    wrong than one that is possible (perhaps even easy?) to use right.
    But also, I think passing over bugs like the above as
    ones only bad developers would make is wrong. Sure, most of us will avoid a bug like that,
    working alone on a piece of code that we are designing, but that's not how applications are
    developed. Instead, what would happen is something like this. Developer A writes some code
    using the lazy stream and does all the exception handling correctly. A few months later,
    developer B needs to make some changes, and moves some of the stream processing to a
    different location, further distant from the bulk of the database interactions. Developer B
    is careful and scrupulous though, and sees that the exception handling needs to be in place
    now in the new location. That works fine, until developer C works on the processing and
    just sees that there's a <code>Stream&lt;Foo&gt;</code> being handled. During refactoring,
    the annoying try/catch block is removed. All the tests pass, and even running the application
    several times shows no problems.
</p>

<p>
    Finally, after everything has been in production for several months, one evening the network team is
    making some changes that cause the application and database servers to be temporarily
    partitioned. What would normally be properly handled by the database error handling
    code, even if it resulted in errors visible to the user, would be cleaned up and reported
    properly. As it is, only the top-level application exception handler sees the problem,
    and it does not do the proper clean-up, just logs something and moves on. Now the application's
    database connection pool is being poisoned, since exceptions are happening on the
    connections, and they are not being cleaned up. Eventually, the application is up and
    running, but becomes unresponsive, and won't allow users to login.
</p>

<p>
    That's your 2AM problem. Requests are made, but just block, not logging any errors. The
    network team is paged, but they report their changes were completed and they can ping to
    and from all the relevant servers. The database engineers are also woken up, but they can
    connect to the database fine, and have no reason to think anything is wrong. Finally,
    the software engineers start looking at the server, and cannot see anything wrong. There
    is nothing in the last few releases that could have changed to make something like this
    happen. The exceptions that led to the problem happened hours ago, and in any case, they
    don't look like they are anything particularly worrying: just database connection problems
    when the network was being reconfigured. Eventually, a hard reboot solves the problem
    and everyone goes back to bed. In the morning, some of the developers half-heartedly
    look at the problem, but no one really understands what happened. A time bomb exists
    in the code. Maybe someone will find it eventually, or everyone will just accept that
    whenever there are network changes, such-and-such an application needs to be rebooted.
</p>

<p>
    Lazy streams in Java are a powerful abstraction that allows some programming tasks
    to be expressed in very elegant and expressive ways. But they violate some deeply
    held intuitions most of us have about how Java code executes.
    Lazy objects violate locality and
    happens-before relations. Like a <code>Future</code>, they seem to change the
    guarantee that the semi-colon operator is a sequence point: dividing the code into
    two parts, the first of which is totally completed before anything happens in the second.
</p>

<p>
    One way applications become buggy is because there are too many powerful abstractions
    woven together in patterns that are too complicated for the developers to reason about
    clearly. Hrorm expresses an opinion about how database interactions should work, it
    isn't right for all situations and needs, but I believe it makes things more reliable.
    Does that mean hrorm is bug-free or perfectly reliable? Of course not. But I hope it
    does mean that when problems with and around hrorm happen, they will happen fast and
    loud, so they will at least be easy to understand.
</p>

</body>

</html>
