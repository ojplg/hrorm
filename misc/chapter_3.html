<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Chapter 3</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.0/mini-default.min.css">
</head>

<body>

<p>
    We are spoiled in the Java world. For almost any programming task you
    can imagine there are many freely available, open source projects you
    can choose from.
    If I was a programmer manager and my team came to me and suggested that
    we write our own ORM framework, I would send them home and tell them to
    come back when they sobered up.
    Nevertheless, when I was working on a personal project beginning last
    year, I could not find what I wanted, and so I began <a href="https://hrorm.org">hrorm</a>.
    I've written some articles about hrorm (for example,
    <a href="https://dzone.com/articles/introducing-hrorm-a-simple-declarative-type-checke">here</a>)
    that describe some aspects of hrorm. In this article, I want to talk about some
    of the questions I faced in writing hrorm, and why I made some of the choices
    I did.
</p>

<h3>Libraries and Frameworks</h3>

<p>
    As an application developer I prefer libraries to frameworks. I won't try to formally
    distinguish between the two, but I think most programmers have some idea about
    the distinction I am making. Libraries are imported by putting a jar file
    in your classpath; they provide clients with classes and methods; they define interfaces
    and then provide implementations of them. Frameworks require set-up and
    configuration and containers; they have interfaces they expect clients to
    to implement; they start up threads and start doing work before you even call
    them.
</p>

<p>
    Frameworks can deliver big bang for the buck of course. With very little
    programming work (but perhaps rather a lot of research and learning work) frameworks
    can allow small teams of developers to build big applications quickly. But it
    comes with a cost. Frameworks can be magical, and magical can mean unpredictable,
    hard to debug, having confusing performance characteristics, and making seemingly
    simple things incredibly frustrating if the authors have not anticipated your
    particular needs.
    That's perhaps unfair, and many frameworks are terrific, but I like using libraries
    better. If something is going to venture into framework territory, it better give
    me something very valuable for the added complexity they bring.
</p>

<p>
    The paradigmatic example in my mind of a library is something like the apache
    or guava collections. A bunch of classes you can use (or not) by just putting
    a jar file in your classpath. No configuration or set-up needed. And the library
    just does what you ask of it. If you don't create instances of the classes or
    call their methods, it doesn't require a bunch of set-up or run threads in your
    application. And when you encounter a problem the stack traces make sense, they
    don't flood your screen with lines of ConfigurationManagerProviderImplementationDirector
    objects doing reflection.
</p>

<h3>Cleverness</h3>

<p>
    One of my favorite programming aphorisms is Brian Kernighan's comment on debugging:
    "Debugging is twice as hard as writing the code in the first place.
    Therefore, if you write the code as cleverly as possible, you are,
    by definition, not smart enough to debug it." My corollary to his theorem is
    that you are twice as stupid at two in the morning when called by the operations
    team than you are during the work day. And therefore, if you have to debug
    clever code at two in the morning, you are 4 times stupider than you need to be.
</p>

<p>
    Hrorm is not a library that is built to impress when you are fully caffeinated and
    relaxing in the post-doughnut mid-morning surfing session on your dual 30 inch
    monitors. It's built for the dead of night when you're trying to sleep one off
    and you don't want to figure out why a lazy sequence cannot be realized, why
    all the threads in the thread pool are simultaneously busy-waiting, or
    why a cache has over a billion entries when there are only a total of a million
    records in the database.
</p>

<p>
    When you call one of hrorm's methods, it does something pretty simple. It generates
    some SQL, it passes it along a <code>Connection</code>, and it parses the results
    into your object model, calling methods that you defined.
</p>

<h3>Laziness</h3>

<p>
    Hrorm is pretty simple. If you call a <code>select()</code> method on a
    hrorm <code>Dao&lt;T&gt;</code> object, you get a fully-realized, eagerly
    created <code>List&lt;T&gt;</code>. There are plenty of times when that
    works fine, but not always.
</p>

<p>
    One of hrorm's contributors has suggested that hrorm include a lazy loading,
    <code>java.util.stream.Stream</code> style interface. The utility of such an
    interface is easy to see. When doing an operation on items read from the
    database, you might not wish to have all the objects you plan to operate
    on resident in memory simultaneously. A method that returned <code>Stream&lt;Entity&gt;</code>
    could be backed by a <code>javax.sql.Connection</code> that read only some
    small number of items at a time, as required by running program. One the
    stream was exhausted, and the calculation complete, closing the <code>Stream</code>
    could automatically close the <code>Connection</code>. It's a very reasonable
    design to solve a real problem. So, why have I resisted it?
</p>

<p>
    The <code>Stream</code> API is a powerful and worthwhile addition to the language.
    I myself find that I mostly use it for cases like this:
</p>

<pre>
    List&lt;Foo&gt; foos = someFunctionThatGetsTheFoos();
    List&lt;Bar&gt; bars = foos.stream().map(transformationFunction).collect(Collectors.toList());
</pre>

<p>
    That's a good improvement from the older days of Java, but really for those cases,
    I would just like <code>List</code> to implement <code>map</code> directly, it would
    save some noise in the code. The problem is that Java's type system does
    not really have a way to express an ML-style functor: a container that preserves its
    own character, while modifying the contents.
</p>

<p>
    Even though there's a lot of code that looks like the above in the world, that's not
    really what <code>Stream</code> is for. To quote the Javadocs, a <code>Stream</code>
    is "A sequence of elements supporting sequential and parallel aggregate operations."
    That sounds somewhat like what we want in the lazy sequence of database elements, but
    there are some mismatches.
</p>

<p>
    First of all, it's not going to support parallel operations. A <code>Connection</code>
    backed <code>Stream</code> will only support sequential operations. A good use for
    <code>Stream</code> is when we want to write some processing code that is impervious
    to how the underlying <code>Stream</code> works, so when appropriate, parallel operations
    can be performed transparently. This is certainly not the impression we want to leave
    the user with.
</p>

<p>
    Instead, hrorm provides a method, <code>foldingSelect</code> that accomplishes more
    or less the same thing as a <code>Stream</code> API would: the user can write a function
    that folds over the result set, accumulating a result while never realizing all the
    data from the database simultaneously.
</p>

<p>
    Perhaps none of that is very convincing to you, so how about an example of what can go wrong?
    (Showing some code that looks like hrorm, but uses a method that does not actually
    exist.)
</p>

<pre>
    try {
        Connection connection = connectionFactory.get();
        Dao&lt;Foo&gt; fooDao = fooDaoBuilder.buildDao(connection);
        // this method does not exist
        Stream&lt;Foo&gt; fooStream = fooDao.lazySelect();
    } catch(HrormException ex){
        // hrorm wraps all database errors with its own extension of RuntimeException
        handleDatabaseProblems(ex);
    }
    processStream(fooStream);
</pre>

<p>
    That code has a problem that many readers probably noticed: the <code>processStream()</code>
    method should be inside the try-catch block, since it still uses the <code>Connection</code>
    and can throw database exceptions. And now the reader might object: sure, that's a problem,
    but people understand how live database streams work, and the docs can explain it, etc. Only
    a noob would make an error like that.
</p>

<p>
    My answer is two parts. One is that I would rather write a library that is hard to use
    wrong than one that is possible (perhaps even easy?) to use right.
    But also, I think passing over bugs like the above as
    ones only bad developers would make is wrong. Sure, most of us will avoid a bug like that,
    working alone on a piece of code that we are designing, but that's not how applications are
    developed. Instead, what would happen is something like this. Developer A writes some code
    using the lazy stream and does all the exception handling correctly. A few months later,
    developer B needs to make some changes, and moves some of the stream processing to a
    different location, further distant from the bulk of the database interactions. Developer B
    is careful and scrupulous though, and sees that the exception handling needs to be in place
    now in the new location. That works fine, until developer C works on the processing and
    just sees that there's a <code>Stream&lt;Foo&gt;</code> being handled. During refactoring,
    the annoying try/catch block is removed. All the tests pass, and even running the application
    several times shows no problems.
</p>

<p>
    Finally, after everything has been in production for several months, one evening the network team is
    making some changes that cause the application and database servers to be temporarily
    partitioned. What would normally be properly handled by the database error handling
    code, even if it resulted in errors visible to the user, would be cleaned up and reported
    properly. As it is, only the top-level application exception handler sees the problem,
    and it does not do the proper clean-up, just logs something and moves on. Now the application's
    database connection pool is being poisoned, since exceptions are happening on the
    connections, and they are not being cleaned up. Eventually, the application is up and
    running, but becomes unresponsive, and won't allow users to login.
</p>

<p>
    That's your 2AM problem. Requests are made, but just block, not logging any errors. The
    network team is paged, but they report their changes were completed and they can ping to
    and from all the relevant servers. The database engineers are also woken up, but they can
    connect to the database fine, and have no reason to think anything is wrong. Finally,
    the software engineers start looking at the server, and cannot see anything wrong. There
    is nothing in the last few releases that could have changed to make something like this
    happen. The exceptions that led to the problem happened hours ago, and in any case, they
    don't look like they are anything particularly worrying: just database connection problems
    when the network was being reconfigured. Eventually, a hard reboot solves the problem
    and everyone goes back to bed. In the morning, some of the developers half-heartedly
    look at the problem, but no one really understands what happened. A time bomb exists
    in the code. Maybe someone will find it eventually, but there are some real hurdles to
    overcome: the introduction of the bug to the program is distant in time from its
    discovery, its hard to reproduce, the side-effects visible in the logs do not
    directly point to the root of the problem. Maybe everyone will just accept that
    whenever there are network changes, such-and-such an application needs to be rebooted.
</p>

<p>
    Lazy streams in Java are a powerful abstraction that allows some programming tasks
    to be expressed in very elegant and expressive ways. But they violate some deeply
    held intuitions most of us have about how Java code executes. Lazy objects violate locality and
    happens-before relations. Like a <code>Future</code>, they seem to remove the
    guarantee that the semi-colon operator is a sequence point: dividing the code into
    two parts, the first of which is totally completed before anything happens in the second.
</p>

<p>
    One way applications become buggy is because there are too many powerful features
    woven together in patterns that are too complicated for the developers to reason about
    clearly. Hrorm expresses an opinion about how database interactions should work, it
    isn't right for all situations and needs, but I believe it makes things more reliable.
    Does that mean hrorm is bug-free or perfectly reliable? Of course not. But I hope it
    does mean that when problems with and around hrorm happen, they will happen fast and
    loud, so they will at least be easy to understand.
</p>




</body>

</html>
